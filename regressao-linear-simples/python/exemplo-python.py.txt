#!/usr/bin/env python3
"""
Regress√£o Linear Simples em Python
Implementa√ß√£o usando apenas a biblioteca padr√£o (sem numpy, pandas, sklearn)
"""

import csv
import sys
import math
from typing import List, Tuple, Optional


class DataPoint:
    """Representa um ponto de dados com coordenadas X e Y"""
    
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"({self.x:.4f}, {self.y:.4f})"


class LinearRegression:
    """Modelo de regress√£o linear simples implementado do zero"""
    
    def __init__(self):
        self.slope: float = 0.0          # coeficiente angular (Œ≤1)
        self.intercept: float = 0.0      # intercepto (Œ≤0)
        self.r_squared: float = 0.0      # coeficiente de determina√ß√£o
        self.is_trained: bool = False    # indica se o modelo foi treinado
        self.n_samples: int = 0          # n√∫mero de amostras usadas no treinamento
    
    def train(self, data: List[DataPoint]) -> None:
        """
        Treina o modelo usando o m√©todo dos m√≠nimos quadrados
        
        Args:
            data: Lista de pontos de dados (DataPoint)
            
        Raises:
            ValueError: Se n√£o houver dados suficientes
        """
        if len(data) < 2:
            raise ValueError("S√£o necess√°rios pelo menos 2 pontos de dados para treinar o modelo")
        
        self.n_samples = len(data)
        
        # Calcular somas necess√°rias
        sum_x = sum(point.x for point in data)
        sum_y = sum(point.y for point in data)
        sum_xy = sum(point.x * point.y for point in data)
        sum_x2 = sum(point.x * point.x for point in data)
        
        # Calcular m√©dias
        mean_x = sum_x / self.n_samples
        mean_y = sum_y / self.n_samples
        
        # Calcular coeficientes usando f√≥rmulas dos m√≠nimos quadrados
        denominator = sum_x2 - (sum_x * sum_x) / self.n_samples
        
        if abs(denominator) < 1e-10:
            raise ValueError("Vari√¢ncia zero em X: n√£o √© poss√≠vel calcular regress√£o linear")
        
        self.slope = (sum_xy - (sum_x * sum_y) / self.n_samples) / denominator
        self.intercept = mean_y - self.slope * mean_x
        
        # Calcular R¬≤
        self.r_squared = self._calculate_r_squared(data, mean_y)
        self.is_trained = True
    
    def _calculate_r_squared(self, data: List[DataPoint], mean_y: float) -> float:
        """Calcula o coeficiente de determina√ß√£o (R¬≤)"""
        ss_res = 0.0  # soma dos quadrados dos res√≠duos
        ss_tot = 0.0  # soma total dos quadrados
        
        for point in data:
            predicted = self.predict(point.x)
            ss_res += (point.y - predicted) ** 2
            ss_tot += (point.y - mean_y) ** 2
        
        # Se n√£o h√° varia√ß√£o em Y, R¬≤ = 1
        if ss_tot == 0:
            return 1.0
        
        return 1 - (ss_res / ss_tot)
    
    def predict(self, x: float) -> float:
        """
        Faz uma predi√ß√£o para um dado valor de X
        
        Args:
            x: Valor de entrada
            
        Returns:
            Valor predito de Y
        """
        if not self.is_trained:
            print("Aviso: modelo n√£o foi treinado ainda")
            return 0.0
        
        return self.intercept + self.slope * x
    
    def get_equation(self) -> str:
        """Retorna a equa√ß√£o da reta como string"""
        if not self.is_trained:
            return "Modelo n√£o treinado"
        
        sign = "+" if self.intercept >= 0 else ""
        return f"y = {self.slope:.4f}x {sign} {self.intercept:.4f}"
    
    def print_summary(self) -> None:
        """Imprime um resumo detalhado do modelo treinado"""
        if not self.is_trained:
            print("Modelo n√£o foi treinado ainda")
            return
        
        print("\n" + "=" * 30)
        print("    RESUMO DO MODELO")
        print("=" * 30)
        print(f"Equa√ß√£o da reta: {self.get_equation()}")
        print(f"Coeficiente angular (slope): {self.slope:.6f}")
        print(f"Intercepto: {self.intercept:.6f}")
        print(f"R¬≤ (coef. determina√ß√£o): {self.r_squared:.6f}")
        print(f"Qualidade do ajuste: {self.r_squared * 100:.2f}%")
        print(f"Amostras utilizadas: {self.n_samples}")


def is_number(s: str) -> bool:
    """Verifica se uma string pode ser convertida para float"""
    try:
        float(s.strip())
        return True
    except ValueError:
        return False


def is_header(row: List[str]) -> bool:
    """Verifica se uma linha parece ser um header (cont√©m texto n√£o num√©rico)"""
    return not all(is_number(field) for field in row if field.strip())


def parse_float(s: str) -> float:
    """Converte string para float com tratamento de espa√ßos"""
    return float(s.strip())


def read_csv(filename: str) -> List[DataPoint]:
    """
    L√™ arquivo CSV e retorna lista de DataPoints
    
    Args:
        filename: Nome do arquivo CSV
        
    Returns:
        Lista de pontos de dados
        
    Raises:
        FileNotFoundError: Se arquivo n√£o for encontrado
        ValueError: Se n√£o houver dados v√°lidos
    """
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            csv_reader = csv.reader(file)
            rows = list(csv_reader)
    except FileNotFoundError:
        raise FileNotFoundError(f"Arquivo '{filename}' n√£o encontrado")
    except Exception as e:
        raise ValueError(f"Erro ao ler arquivo CSV: {e}")
    
    if not rows:
        raise ValueError("Arquivo CSV est√° vazio")
    
    data = []
    start_row = 0
    
    # Verificar se primeira linha √© header
    if rows and is_header(rows[0]):
        start_row = 1
        print(f"Header detectado: {rows[0]}")
    
    # Processar dados
    for i in range(start_row, len(rows)):
        row = rows[i]
        
        # Pular linhas vazias
        if not row or all(not field.strip() for field in row):
            continue
            
        if len(row) < 2:
            print(f"Linha {i + 1} ignorada: menos de 2 colunas")
            continue
        
        try:
            x = parse_float(row[0])
            y = parse_float(row[1])
            data.append(DataPoint(x, y))
        except ValueError as e:
            print(f"Linha {i + 1} ignorada: erro ao converter dados '{row[0]}', '{row[1]}': {e}")
            continue
    
    if not data:
        raise ValueError("Nenhum dado v√°lido encontrado no arquivo")
    
    print(f"Carregados {len(data)} pontos de dados do arquivo '{filename}'")
    return data


def show_data_sample(data: List[DataPoint], limit: int = 10) -> None:
    """Mostra uma amostra dos dados carregados"""
    print("\n" + "=" * 25)
    print("   AMOSTRA DOS DADOS")
    print("=" * 25)
    print("X\t\tY")
    print("-" * 20)
    
    display_limit = min(limit, len(data))
    
    for i in range(display_limit):
        print(f"{data[i].x:.4f}\t\t{data[i].y:.4f}")
    
    if len(data) > limit:
        print(f"... e mais {len(data) - limit} pontos")


def make_predictions(model: LinearRegression, data: List[DataPoint]) -> None:
    """Faz predi√ß√µes de exemplo usando o modelo treinado"""
    print("\n" + "=" * 50)
    print("           PREDI√á√ïES DE EXEMPLO")
    print("=" * 50)
    print("X\t\tY Real\t\tY Predito\tErro")
    print("-" * 50)
    
    # Usar alguns pontos dos dados para mostrar predi√ß√µes
    step = max(1, len(data) // 5)
    
    for i in range(0, len(data), step):
        point = data[i]
        predicted = model.predict(point.x)
        error = point.y - predicted
        print(f"{point.x:.4f}\t\t{point.y:.4f}\t\t{predicted:.4f}\t\t{error:.4f}")


def calculate_statistics(data: List[DataPoint]) -> dict:
    """Calcula estat√≠sticas b√°sicas dos dados"""
    x_values = [point.x for point in data]
    y_values = [point.y for point in data]
    
    stats = {
        'n': len(data),
        'x_min': min(x_values),
        'x_max': max(x_values),
        'x_mean': sum(x_values) / len(x_values),
        'y_min': min(y_values),
        'y_max': max(y_values),
        'y_mean': sum(y_values) / len(y_values)
    }
    
    # Calcular desvio padr√£o
    x_variance = sum((x - stats['x_mean']) ** 2 for x in x_values) / len(x_values)
    y_variance = sum((y - stats['y_mean']) ** 2 for y in y_values) / len(y_values)
    
    stats['x_std'] = math.sqrt(x_variance)
    stats['y_std'] = math.sqrt(y_variance)
    
    return stats


def show_data_statistics(data: List[DataPoint]) -> None:
    """Mostra estat√≠sticas descritivas dos dados"""
    stats = calculate_statistics(data)
    
    print("\n" + "=" * 35)
    print("      ESTAT√çSTICAS DOS DADOS")
    print("=" * 35)
    print(f"N√∫mero de observa√ß√µes: {stats['n']}")
    print(f"\nVari√°vel X:")
    print(f"  M√≠nimo: {stats['x_min']:.4f}")
    print(f"  M√°ximo: {stats['x_max']:.4f}")
    print(f"  M√©dia: {stats['x_mean']:.4f}")
    print(f"  Desvio padr√£o: {stats['x_std']:.4f}")
    print(f"\nVari√°vel Y:")
    print(f"  M√≠nimo: {stats['y_min']:.4f}")
    print(f"  M√°ximo: {stats['y_max']:.4f}")
    print(f"  M√©dia: {stats['y_mean']:.4f}")
    print(f"  Desvio padr√£o: {stats['y_std']:.4f}")


def interpret_model_quality(r_squared: float) -> None:
    """Interpreta a qualidade do modelo baseado no R¬≤"""
    print("\n" + "=" * 35)
    print("        INTERPRETA√á√ÉO")
    print("=" * 35)
    
    if r_squared > 0.9:
        quality = "Excelente"
        description = "O modelo explica mais de 90% da varia√ß√£o dos dados."
    elif r_squared > 0.7:
        quality = "Bom"
        description = "O modelo explica uma boa parte da varia√ß√£o dos dados."
    elif r_squared > 0.5:
        quality = "Moderado"
        description = "H√° alguma correla√ß√£o linear, mas com limita√ß√µes."
    elif r_squared > 0.3:
        quality = "Fraco"
        description = "Correla√ß√£o linear fraca. Considere outros modelos."
    else:
        quality = "Muito fraco"
        description = "Os dados podem n√£o ter rela√ß√£o linear clara."
    
    print(f"Qualidade do ajuste: {quality}")
    print(f"R¬≤ = {r_squared:.4f} ({r_squared * 100:.2f}%)")
    print(f"{description}")


def show_usage() -> None:
    """Mostra instru√ß√µes de uso do programa"""
    program_name = sys.argv[0]
    print(f"Uso: python {program_name} <arquivo.csv>")
    print("\nO arquivo CSV deve ter pelo menos 2 colunas (X, Y)")
    print("A primeira linha pode ser um header (ser√° detectado automaticamente)")
    print("\nExemplo:")
    print(f"  python {program_name} dados.csv")


def main() -> None:
    """Fun√ß√£o principal do programa"""
    # Verificar argumentos da linha de comando
    if len(sys.argv) != 2:
        show_usage()
        sys.exit(1)
    
    filename = sys.argv[1]
    print(f"üîç Carregando dados de: {filename}")
    
    try:
        # Ler dados do CSV
        data = read_csv(filename)
        
        # Mostrar estat√≠sticas e amostra dos dados
        show_data_statistics(data)
        show_data_sample(data)
        
        # Criar e treinar modelo
        print(f"\nü§ñ Treinando modelo de regress√£o linear...")
        model = LinearRegression()
        model.train(data)
        
        # Mostrar resultados
        model.print_summary()
        
        # Fazer predi√ß√µes de exemplo
        make_predictions(model, data)
        
        # Interpretar qualidade do modelo
        interpret_model_quality(model.r_squared)
        
        # Mostrar como usar o modelo
        print(f"\nüìã Para fazer novas predi√ß√µes, use:")
        print(f"   y = {model.slope:.4f} * x + {model.intercept:.4f}")
        
        print(f"\n‚úÖ An√°lise conclu√≠da com sucesso!")
        
    except (FileNotFoundError, ValueError) as e:
        print(f"‚ùå Erro: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print(f"\n‚ö†Ô∏è  Opera√ß√£o cancelada pelo usu√°rio")
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
